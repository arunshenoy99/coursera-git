1. UNDOING CHANGES BEFORE COMMITING(tracked files only)
	git checkout <filename>
	HERE FILENAME MUST BE MODIFIED AND HENCE REVERT BACK THE ITS VERSION IN THE LATEST STORAGE SNAPSHOT
	git checkout -p WILL ASK LINE BY LINE AND ASK IF YOU WANT THAT LINE TO PREVIOUS VERSION
	git reset HEAD <filename> TAKES THE FILE IN STAGING AREA TO UNTRACKED

2. AMENDING A COMMIT(I.E ADD NEW FILE TO PREVIOUS COMMIT OR CHANGE COMMIT MESSAGE)
	MAKE THE NECESSARY CHANGES THEN DO
	git commit --amend (OPENS AN EDITOR AND SHOWS VARIOUS DETAILS OF AMENDMENT)
	NEVER USE AMEND WHEN WORKING WITH PUSH REPO'S(AVOID AMENDING COMMITS WHEN COMMIT IS ALREADY PUBLIC)

3. REVERTING A FAULTY COMMIT
	REVERT DOES NOT DELETE A COMMIT AND MOVE HEAD TO PREVIOUS COMMIT RATHER IT CREATES A NEW COMMIT WHICH IS THE INVERSE OF THE PREVIOUS COMMIT(IE IF A LINE WAS ADDED IN THE 
	PREVIOUS COMMIT IT GETS REMOVED IN THE NEW COMMIT) HENCE WE CAN KEEP TRACK OF EXACTLY WHAT HAPPENED
	git revert HEAD
	OPENS TEXT EDITOR WITH CHANGES

4. REVERTING TO A PARTICULAR COMMIT
	GIT USES A SHA-1 HASH FOR EACH COMMIT ID HENCE VERIFYING INTEGRITY OF DATA
	git revert <commitID> or <partofcommitID> OPENS EDITOR DESCRIBING ROLLBACK OF <commitID>

